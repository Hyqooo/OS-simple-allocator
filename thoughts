1. There's one interesting feature of C99 compiler:
  - we can define zero-length arrays to provide extandable arrays, which length
  originally have not known, but we can always know how much memory are taken

2. This computer has 48-bit long virtual addresses
3. Call of the sbrk(0) first time differes from sbrk(0) on the second time(?)
  - It seems like it returns first some old value of the program break

4. Simple memory allocator can be implemented using linked list data structure.
  Each allocated block will be preceded by a header containing metadata.
  Metadata:
    - prev, next: pointers to metadata describing the adjacent blocks
    - free: a boolean describing whether or not this block is free
    - size: the allocated size of the block of memory

5. Allocation
  void *mm_malloc(size_t size);

  The returned pointer must point to the beginning of the allocated space, not metadata header.

  One simple algorithm for finding available memory is called first fit. When your memory allocator is called to allocate some memory, it iterates through its block until it finds a siffuciently large free block of memory.

  - If no sufficiently large free block is found, use sbrk to create more space on the heap
  - If the first block of memory you find is so big that is can accommodate both the newly allocated block and another block in addition, then the block is split in two; one block to hold the newly allocated block, and residula free block. If it's a bit larger than what you need, but not big enough for a new block( i.e it's not big enough to hold the metadata of a new block), be aware that you will have some unused space at the end of the block
  - Return NULL if you cannot allocate the new requested size.
  - Return NULL if the requested size is 0.
  - I can to not zero-fill my allocated memory before returning a pointer to it.

6. We can't use array of voids, but stackoverflow suggests to use char for this array 'cause char is always 1 byte long, but I need to be careful and I need to do memory allocation properly

7. It's interesting seems that OS doesn't check boundaries of the brk.
  - Actually it's not true, this is result of undefined behaviour.

8. There's a bug when we use litarals they have different address of memory and 
we can't easily free this memory because we don't know where the header is. 
I think we need go through all the list and find memory address that contains pointer to this literal
